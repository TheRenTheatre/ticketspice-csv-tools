#!/usr/bin/env ruby -w

require 'csv'
require 'date'
require 'time'
require 'awesome_print'
require 'active_support/core_ext/object/inclusion'

REQUIRED_TICKETSPICE_FIELDS = ["Order Number",
                               "Date Completed",
                               "Page Name",
                               "Date Selection",
                               "Timeslot Selection",
                               "Billing Name (First Name)",
                               "Billing Name (Last Name)",
                               "Billing Email Address",
                               "Billing Phone Number",
                               "Billing Address (Address 1)",
                               "Billing Address (Address 2)",
                               "Billing Address (City)",
                               "Billing Address (State/Province)",
                               "Billing Address (Country)",
                               "Billing Address (Postal Code)"]

                               # TODO check for the two other Phone Number
                               # fields and the four versions of the
                               # "Added Donation ($ Amount)" field.

def warn_usage_and_abort
  list_of_fields = [REQUIRED_TICKETSPICE_FIELDS.map(&:inspect) + ['"Added Donation (Amount)" columns']]
  warn "\nUsage: #{$0} path/to/orders.csv\n\n" +
       "Required fields:\n" +
        "  - " + list_of_fields.join("\n  - ") + "\n\n"
  exit 1
end

warn_usage_and_abort unless ARGV.length == 1


def tags_to_apply(page_name, date_selection, timeslot_selection, date_completed, added_donation_amount, csv_row)
  tags = []
  if date_selection.nil? # one-off events
    date = year = nil
  else
    date = Date.parse(date_selection)
    year = date.year
  end

  if page_name == "Nosferatu" && year == 2021
    tags << "Patrons - 2021 - Nosferatu, Entire Run"
    tags << case date
            when Date.parse("2021-10-01")..Date.parse("2021-10-02")
              "Patrons - 2021 - Nosferatu, 1st Week"
            when Date.parse("2021-10-08")..Date.parse("2021-10-09")
              "Patrons - 2021 - Nosferatu, 2nd Week"
            when Date.parse("2021-10-15")..Date.parse("2021-10-16")
              "Patrons - 2021 - Nosferatu, 3rd Week"
            when Date.parse("2021-10-22")..Date.parse("2021-10-23")
              "Patrons - 2021 - Nosferatu, 4th Week"
            when Date.parse("2021-10-28")..Date.parse("2021-10-31")
              "Patrons - 2021 - Nosferatu, 5th Week"
            when Date.parse("2021-11-05")..Date.parse("2021-11-06")
              "Patrons - 2021 - Nosferatu, 6th Week"
            else raise "Unknown show date for Nosferatu: #{date}"
            end

  elsif page_name == "The Office Holiday Party Musical Extravaganza Show" && year == 2021
    tags << "Patrons - 2021 - The Office Holiday Party Musical Extravaganza Show, Entire Run"
    tags << case date
            when Date.parse("2021-12-02")..Date.parse("2021-12-05")
              "Patrons - 2021 - The Office Holiday Party Musical Extravaganza Show, 1st Week"
            when Date.parse("2021-12-09")..Date.parse("2021-12-12")
              "Patrons - 2021 - The Office Holiday Party Musical Extravaganza Show, 2nd Week"
            when Date.parse("2021-12-16")..Date.parse("2021-12-19")
              "Patrons - 2021 - The Office Holiday Party Musical Extravaganza Show, 3rd Week"
            else raise "Unknown show date for Office Party: #{date}"
            end

  elsif page_name =~ /^Dickens by Candl?elight$/ && year == 2021
    # It was misspelled "Candelight" in Ticketspice
    tags << "Patrons - 2021 - Dickens by Candlelight, Entire Run"

  elsif page_name == "La Medéa" && year == 2022
    tags << "Patrons - 2022 - La Medéa, Entire Run"
    tags << case date
            when Date.parse("2022-01-21")..Date.parse("2022-01-23")
              "Patrons - 2022 - La Medéa, 1st Week"
            when Date.parse("2022-01-28")..Date.parse("2022-01-30")
              "Patrons - 2022 - La Medéa, 2nd Week"
            when Date.parse("2022-02-04")..Date.parse("2022-02-06")
              "Patrons - 2022 - La Medéa, 3rd Week"
            when Date.parse("2022-02-10")..Date.parse("2022-02-13")
              "Patrons - 2022 - La Medéa, 4th Week"
            else raise "Unknown show date for La Medéa: #{date}"
            end

  elsif page_name == "Stephen Pugh in Concert"
    # One-off event: Feb 9 2022 at 8 PM
    year = 2022
    tags << "Patrons - 2022 - Stephen Pugh in Concert"

  elsif page_name == "Laurel Hatfield in Concert"
    # One-off event: Feb 22 2022 at 8 PM
    year = 2022
    tags << "Patrons - 2022 - Laurel Hatfield in Concert"

  elsif page_name == "Oscar Wilde and Jesus Christ Walk Into a Gay Bar" && year == 2022
    tags << "Patrons - 2022 - Oscar Wilde and Jesus Christ Walk Into a Gay Bar, Entire Run"
    tags << case date
            when Date.parse("2022-02-20")
              "Patrons - 2022 - Oscar Wilde and Jesus Christ Walk Into a Gay Bar, 1st Week"
            when Date.parse("2022-02-27")
              "Patrons - 2022 - Oscar Wilde and Jesus Christ Walk Into a Gay Bar, 2nd Week"
            when Date.parse("2022-03-06")
              "Patrons - 2022 - Oscar Wilde and Jesus Christ Walk Into a Gay Bar, 3rd Week"
            when Date.parse("2022-03-13")
              "Patrons - 2022 - Oscar Wilde and Jesus Christ Walk Into a Gay Bar, 4th Week"
            when Date.parse("2022-03-20")
              "Patrons - 2022 - Oscar Wilde and Jesus Christ Walk Into a Gay Bar, 5th Week"
            when Date.parse("2022-03-27")
              warn "  - warning: we cancelled the Mar 27, 2022 show of Oscar Wilde, but there's a completed order for it:\n" +
                   "             #{printable_order_summary(csv_row)}\n\n"
              nil
            when Date.parse("2022-04-03")
              warn "  - warning: we cancelled the Apr 3, 2022 show of Oscar Wilde, but there's a completed order for it:\n" +
                   "             #{printable_order_summary(csv_row)}\n\n"
              nil
            when Date.parse("2022-04-10")
              "Patrons - 2022 - Oscar Wilde and Jesus Christ Walk Into a Gay Bar, 8th Week"
            else raise "Unknown show date for Oscar Wilde and Jesus Christ Walk Into a Gay Bar: #{date}"
            end

  elsif page_name == "Gorgeous" && year == 2022
    tags << "Patrons - 2022 - Gorgeous, Entire Run"
    tags << case date
            when Date.parse("2022-03-04")..Date.parse("2022-03-06")
              "Patrons - 2022 - Gorgeous, 1st Week"
            when Date.parse("2022-03-11")..Date.parse("2022-03-13")
              "Patrons - 2022 - Gorgeous, 2nd Week"
            when Date.parse("2022-03-18")..Date.parse("2022-03-20")
              "Patrons - 2022 - Gorgeous, 3rd Week"
            when Date.parse("2022-03-25")..Date.parse("2022-03-27")
              "Patrons - 2022 - Gorgeous, 4th Week"
            when Date.parse("2022-03-31")..Date.parse("2022-04-03")
              "Patrons - 2022 - Gorgeous, 5th Week"
            when Date.parse("2022-04-07")..Date.parse("2022-04-10")
              warn "  - warning: we cancelled the 6th week of Gorgeous, but there's a completed order for it:\n" +
                   "             #{printable_order_summary(csv_row)}\n\n"
              nil
            else raise "Unknown show date for Gorgeous: #{date}"
            end

  elsif page_name == "Ain't Done Bad" && year == 2022
    tags << "Patrons - 2022 - Ain't Done Bad, Entire Run"
    tags << case date
            when Date.parse("2022-04-23")
              if timeslot_selection == "9:00 PM"
                warn "  - warning: we cancelled the 9 PM show of Ain't Done Bad on 4/23/2022, but there's a completed order for it:\n" +
                     "             #{printable_order_summary(csv_row)}\n\n"
                nil
              elsif timeslot_selection == "7:00 PM"
                "Patrons - 2022 - Ain't Done Bad, 1st Week"
              else
                raise "Unknown show time for Ain't Done Bad: #{timeslot_selection} on #{date}"
              end
            when Date.parse("2022-04-21")..Date.parse("2022-04-24")
              "Patrons - 2022 - Ain't Done Bad, 1st Week"
            when Date.parse("2022-04-27")..Date.parse("2022-05-01")
              "Patrons - 2022 - Ain't Done Bad, 2nd Week"
            else raise "Unknown show date for Ain't Done Bad: #{date}"
            end

  elsif page_name == "From Here: In Concert" && year == 2022
    # One weekend, but let's use "Entire Run" since it was three performances
    tags << "Patrons - 2022 - From Here: In Concert, Entire Run"

  elsif page_name == "Bullock and the Bandits" && year == 2022
    tags << "Patrons - 2022 - Bullock and the Bandits, All Shows"
    tags << case date
            when Date.parse("2022-07-01")
              "Patrons - 2022 - Bullock and the Bandits, Jul 1"
            when Date.parse("2022-10-05")
              "Patrons - 2022 - Bullock and the Bandits, Oct 5"
            when Date.parse("2022-10-12")
              "Patrons - 2022 - Bullock and the Bandits, Oct 12"
            when Date.parse("2022-10-19")
              "Patrons - 2022 - Bullock and the Bandits, Oct 19"
            else raise "Unknown show date for #{page_name}: #{date}"
            end

  elsif page_name == "Spooky & Gay" && year == 2022
    # Single show, but not set up in TicketSpice as a one-off event
    tags << "Patrons - 2022 - Spooky & Gay"

  elsif page_name == "Lenox Ave" && year == 2022
    tags << "Patrons - 2022 - Lenox Ave, Entire Run"
    tags << case date
            when Date.parse("2022-07-22")..Date.parse("2022-07-23")
              "Patrons - 2022 - Lenox Ave, 1st Week"
            when Date.parse("2022-07-29")..Date.parse("2022-07-30")
              "Patrons - 2022 - Lenox Ave, 2nd Week"
            when Date.parse("2022-08-05")..Date.parse("2022-08-06")
              "Patrons - 2022 - Lenox Ave, 3rd Week"
            when Date.parse("2022-08-12")..Date.parse("2022-08-14")
              "Patrons - 2022 - Lenox Ave, 4th Week"
            else raise "Unknown show date for Lenox Ave: #{date}"
            end

  elsif page_name == "Nosferatu" && year == 2022
    tags << "Patrons - 2022 - Nosferatu, Entire Run"
    tags << case date
            when Date.parse("2022-09-23")..Date.parse("2022-09-24")
              "Patrons - 2022 - Nosferatu, 1st Week"
            when Date.parse("2022-09-30")..Date.parse("2022-10-01")
              "Patrons - 2022 - Nosferatu, 2nd Week"
            when Date.parse("2022-10-07")..Date.parse("2022-10-08")
              "Patrons - 2022 - Nosferatu, 3rd Week"
            when Date.parse("2022-10-14")..Date.parse("2022-10-15")
              "Patrons - 2022 - Nosferatu, 4th Week"
            when Date.parse("2022-10-21")..Date.parse("2022-10-22")
              "Patrons - 2022 - Nosferatu, 5th Week"
            when Date.parse("2022-10-27")..Date.parse("2022-10-31")
              "Patrons - 2022 - Nosferatu, 6th Week"
            when Date.parse("2022-11-03")..Date.parse("2022-11-05")
              "Patrons - 2022 - Nosferatu, 7th Week"
            else raise "Unknown show date for Nosferatu: #{date}"
            end

  elsif page_name == "MX OTR The Pageant Experience" && year == 2022
    # Single show, but not set up in TicketSpice as a one-off event
    tags << "Patrons - 2022 - MX OTR The Pageant Experience"

  elsif page_name == "Winnie's Rock Cauldron Cabaret" && year == 2022
    # Single show, but not set up in TicketSpice as a one-off event
    tags << "Patrons - 2022 - Winnie's Rock Cauldron Cabaret"

  elsif page_name == "A Halloween Carol" && year == 2022
    # Single show, but not set up in TicketSpice as a one-off event
    tags << "Patrons - 2022 - A Halloween Carol"

  elsif page_name == "Hexed A Femme Rock Musical" && year == 2022
    tags << "Patrons - 2022 - Hexed, Entire Run"

  elsif page_name == "ASL Slam" && (year == 2022 || year == 2023)
    # Two single shows, not really sure how to tag these yet so we'll just keep with the year for now
    tags << "Patrons - #{year} - ASL Slam"

  elsif page_name == "ASL Slam 3" && year.nil?
    year = 2023
    tags << "Patrons - 2023 - ASL Slam"

  elsif page_name == "The Office Holiday Party Musical Extravaganza Show" && year == 2022
    tags << "Patrons - 2022 - The Office Holiday Party Musical Extravaganza Show, Entire Run"
    tags << case date
            when Date.parse("2022-12-01")..Date.parse("2022-12-03")
              "Patrons - 2022 - The Office Holiday Party Musical Extravaganza Show, 1st Week"
            when Date.parse("2022-12-08")..Date.parse("2022-12-10")
              "Patrons - 2022 - The Office Holiday Party Musical Extravaganza Show, 2nd Week"
            when Date.parse("2022-12-15")..Date.parse("2022-12-17")
              "Patrons - 2022 - The Office Holiday Party Musical Extravaganza Show, 3rd Week"
            when Date.parse("2022-12-22")..Date.parse("2022-12-23")
              "Patrons - 2022 - The Office Holiday Party Musical Extravaganza Show, 4th Week"
            else raise "Unknown show date for Office Party: #{date}"
            end

  elsif page_name == "Black & White Night" && year == 2022
    # Single event, but not set up in TicketSpice as a one-off event
    tags << "Patrons - 2022 - Black & White Night"

  elsif page_name == "6 Guitars" && year == 2023
    tags << "Patrons - 2023 - 6 Guitars, Entire Run"
    tags << case date
            when Date.parse("2023-01-06")..Date.parse("2023-01-07")
              "Patrons - 2023 - 6 Guitars, 1st Week"
            when Date.parse("2023-01-13")..Date.parse("2023-01-14")
              "Patrons - 2023 - 6 Guitars, 2nd Week"
            when Date.parse("2023-01-20")..Date.parse("2023-01-21")
              "Patrons - 2023 - 6 Guitars, 3rd Week"
            when Date.parse("2023-01-27")..Date.parse("2023-01-29")
              "Patrons - 2023 - 6 Guitars, 4th Week"
            else raise "Unknown show date for 6 Guitars: #{date}"
            end

  elsif page_name == "From Here: In Orlando" && year == 2023
    # Two shows on one day; sanity check for future similar show names
    raise "Unexpected date for #{page_name}: #{date}" unless date == Date.parse("2023-01-17")
    tags << "Patrons - 2023 - From Here: In Orlando"

  elsif (page_name == "The Ren Sings" || page_name == "The Ren Sings Dolly") && year == 2023
    # Intermittent series; make sure we catch any future shows
    tags << "Patrons - 2023 - The Ren Sings, All"
    if date == Date.parse("2023-02-18")
      tags << "Patrons - 2023 - The Ren Sings Mariah Carey"
    elsif date == Date.parse("2023-03-31")
      tags << "Patrons - 2023 - The Ren Sings Celine Dion"
    elsif date == Date.parse("2023-05-03")
      tags << "Patrons - 2023 - The Ren Sings Dolly Parton"
    else
      raise "Unexpected date for #{page_name}: #{date}"
    end

  elsif page_name == "Monster Cabaret" && year == 2023
    # Single show; catch any future shows in the series
    raise "Unexpected date for #{page_name}: #{date}" unless date == Date.parse("2023-02-25")
    tags << "Patrons - 2023 - Monster Cabaret"

  elsif page_name == "Beacon Street: A New Musical" && year == 2023
    # Two show run; catch future runs
    raise "Unexpected date for #{page_name}: #{date}" unless date.in?(Date.parse("2023-02-24")..Date.parse("2023-02-25"))
    tags << "Patrons - 2023 - Beacon Street: A New Musical"

  elsif page_name == "Josephine" && year == 2023
    tags << "Patrons - 2023 - Josephine, Entire Run"
    tags << case date
            when Date.parse("2023-03-09")..Date.parse("2023-03-12")
              "Patrons - 2023 - Josephine, 1st Week"
            when Date.parse("2023-03-16")..Date.parse("2023-03-19")
              "Patrons - 2023 - Josephine, 2nd Week"
            else raise "Unknown show date for Josephine: #{date}"
            end

  elsif page_name == "Sincerely, Three: Live at The Ren" && year == 2023
    # Single performance, but not set up in TicketSpice as a one-off event;
    # catch any future shows
    raise "Unexpected date for #{page_name}: #{date}" unless date == Date.parse("2023-03-01")
    tags << "Patrons - 2023 - Sincerely, Three: Live at The Ren"

  elsif (page_name == "Sessions at the Ren" || page_name == "Sessions 2.0") && year == 2023
    # Ongoing series, only two shows so far, keep them together for now
    raise "Unexpected date for #{page_name}: #{date}" unless date.in?([Date.parse("2023-03-04"), Date.parse("2023-04-19")])
    tags << "Patrons - 2023 - Sessions at the Ren"

  elsif page_name == "Circles of Hell: A Staged Workshop" && year == 2023
    # Two show run
    raise "Unexpected date for #{page_name}: #{date}" unless date.in?(Date.parse("2023-03-24")..Date.parse("2023-03-25"))
    tags << "Patrons - 2023 - Circles of Hell: A Staged Workshop"

  elsif page_name == "Mood" && year == 2023
    # Ongoing series, but only one so far; catch any future shows to maybe tag
    # differently
    raise "Unexpected date for #{page_name}: #{date}" unless date == Date.parse("2023-03-25")
    tags << "Patrons - 2023 - Mood"

  elsif page_name == "Mood" && year.nil?
    year = 2023
    # Like so.
    tags << "Patrons - 2023 - Mood"

  elsif page_name == "Titan After Party" && year == 2023
    tags << "Patrons - 2023 - Dragula Titans Tour After-Party"

  elsif page_name == "The Cocaine Play" && year == 2023
    tags << "Patrons - 2023 - The Cocaine Play, Entire Run"
    tags << case date
            when Date.parse("2023-04-13")
              warn "  - warning: we moved the Apr 13, 2023 show of The Cocaine Play, but there's a completed order for it:\n" +
                   "             #{printable_order_summary(csv_row)}\n\n"
              nil
            when Date.parse("2023-04-14")..Date.parse("2023-04-15")
              "Patrons - 2023 - The Cocaine Play, 1st Week"
            when Date.parse("2023-04-20")..Date.parse("2023-04-22")
              "Patrons - 2023 - The Cocaine Play, 2nd Week"
            when Date.parse("2023-04-27")..Date.parse("2023-04-29")
              "Patrons - 2023 - The Cocaine Play, 3rd Week"
            when Date.parse("2023-05-04")..Date.parse("2023-05-06")
              "Patrons - 2023 - The Cocaine Play, 4th Week"
            else raise "Unknown show date for The Cocaine Play: #{date}"
            end

  elsif (page_name == "Ren Fair Merchants" || page_name == "Outside Ren Fair Merchants") && year == 2023
    tags << "Merchants - 2023 - Renaissance Fair"

  elsif page_name == "I Love Liz"
    # One-off event: Apr 18 2023 at 8 PM
    year = 2023
    tags << "Patrons - 2023 - I Love Liz"

  elsif page_name == "Cabaret Superstar 2023"
    # Event series: Apr 3, Apr 10, Apr 17, Apr 24, and May 1, 2023
    year = 2023
    tags << "Patrons - 2023 - Musical Mondays, Next Cabaret Superstar"

  elsif page_name == "54"
    tags << "Patrons - 2023 - 54, Entire Run"
    tags << case date
      when Date.parse("2023-06-23")..Date.parse("2023-06-24")
        "Patrons - 2023 - 54, 1st Week"
      when Date.parse("2023-06-30")..Date.parse("2023-07-01")
        "Patrons - 2023 - 54, 2nd Week"
      when Date.parse("2023-07-07")..Date.parse("2023-07-08")
        "Patrons - 2023 - 54, 3rd Week"
      when Date.parse("2023-07-14")..Date.parse("2023-07-15")
        "Patrons - 2023 - 54, 4th Week"
      when Date.parse("2023-07-21")..Date.parse("2023-07-22")
        "Patrons - 2023 - 54, 5th Week"
      when Date.parse("2023-07-28")..Date.parse("2023-07-29")
        "Patrons - 2023 - 54, 6th Week"
      when Date.parse("2023-08-04")..Date.parse("2023-08-05")
        "Patrons - 2023 - 54, 7th Week"
      when Date.parse("2023-08-11")..Date.parse("2023-08-12")
        "Patrons - 2023 - 54, 8th Week"
      when Date.parse("2023-08-18")..Date.parse("2023-08-19")
        "Patrons - 2023 - 54, 9th Week"
      when Date.parse("2023-08-25")..Date.parse("2023-08-26")
        "Patrons - 2023 - 54, 10th Week"
      else raise "Unknown show date for 54: #{date}"
      end

  else
    warn "\n\n\n"
    raise "No handler for Page Name #{page_name.inspect} and year #{year.inspect} (parsed from #{date_selection.inspect})\n\n\n"
  end

  # TODO: if someone buys tickets for a future show, is imported as e.g. "Week
  # 3", then changes their tickets to "Week 2" and is imported again, they'll
  # end up tagged with both in Mailchimp. Once this is API-based we could remove
  # the incorrect tags, but there's no way to do that through a CSV. A quick fix
  # would be to leave them out of the show tags until the show has happened, at
  # the expense of not being able to target future patrons for a certain show
  # via Mailchimp alone.

  raise "Error: year wasn't set for order: #{printable_order_summary(csv_row)}" if year.nil?

  if added_donation_amount > 0
    tags << "Donors - #{date_completed.year}"
  end

  tags.compact!

  tags
end

def printable_order_summary(row)
  values = row.to_h.fetch_values("First Name", "Last Name", "Order Number", "Date Selection")
  values[3] ||= "(no date)"
  "%s %s - order number %s - tickets for %s" % values
end

def mailchimp_style_combined_address_field_for_row(row)
  # Docs: https://mailchimp.com/help/import-mailing-addresses-postcards/
  columns = [row["Address - Street Address"],
             row["Address - Address Line 2"],
             row["Address - City"],
             row["Address - State/Prov/Region"],
             row["Address - Zip/Postal"],
             row["Address - Country"]]
  columns.compact!
  columns.map! { |col|
    col.strip.gsub(/\s{2,}/, " ")
  }
  joined = columns.join("  ")

  return nil if joined.strip.empty?
  joined
end

col_num = 0
ticketspice_to_mailchimp_converter = proc { |ticketspice_header|
  translation = Hash.new { |h, key| h[key] = key; key }
  translation.merge!(
    "Billing Name (First Name)"        => "First Name",
    "Billing Name (Last Name)"         => "Last Name",
    "Billing Email Address"            => "Email Address",
    "Billing Phone Number"             => "Phone #{col_num}",
    "Phone Number"                     => "Phone #{col_num}",
    "Billing Address (Address 1)"      => "Address - Street Address",
    "Billing Address (Address 2)"      => "Address - Address Line 2",
    "Billing Address (City)"           => "Address - City",
    "Billing Address (State/Province)" => "Address - State/Prov/Region",
    "Billing Address (Country)"        => "Address - Country",
    "Billing Address (Postal Code)"    => "Address - Zip/Postal",
    "Added Donation ($ Amount)"        => "Added Donation (Amount) #{col_num}",
    "Donation Amount ($ Amount)"       => "Added Donation (Amount) #{col_num}"
  )
  col_num += 1
  translation[ticketspice_header]
}

file_contents = File.read(ARGV[0], encoding: 'bom|utf-8')

# Make sure we have all the fields we need
header_test_csv = CSV.parse(file_contents.lines.first, headers: true)
missing_headers = REQUIRED_TICKETSPICE_FIELDS.sort - header_test_csv.headers.sort
if missing_headers.any?
  warn "\n\nYour orders report is missing these required fields: #{missing_headers.inspect}"
  warn_usage_and_abort
end


# Parse whole file and rename headers to Mailchimp's names
table = CSV.parse(file_contents, headers: true,
                                 header_converters: ticketspice_to_mailchimp_converter)

# Collapse duplicate fields; convert mailing address; add tags
table.each do |row|
  added_donation_amount = row.map { |col, value|
    value.to_f if col.start_with?("Added Donation (Amount)")
  }.compact.sum

  phones = row.map { |col, value|
    if col.start_with?("Phone")
      if value =~ /^1(\d{3})(\d{3})(\d{4})$/
        "(%s) %s-%s" % Regexp.last_match[1..3]
      else
        value
      end
    else
      nil
    end
  }.compact.uniq
  warn "  - warning: more than one Phone for order #{row["Order Number"].inspect}: #{phones.inspect}" if phones.count > 1
  row["Phone"] = phones.first

  # TODO: these values don't mention a TZ. They look like local time, which is
  # usually the same as this machine (America/New_York), so this works anyway for
  # us, but we should pull that in from somewhere.
  date_completed = Time.parse(row["Date Completed"])

  tags = tags_to_apply(row["Page Name"], row["Date Selection"], row["Timeslot Selection"],
                       date_completed, added_donation_amount, row)
  row["Address"] = mailchimp_style_combined_address_field_for_row(row)
  row["Tags"] = tags
end

# Finally, generate a new one that only includes the fields they want
table.by_col!
table.delete_if { |header, data|
  !["First Name", "Last Name", "Email Address", "Phone", "Address", "Tags"].include?(header)
}


# Construct a new table where we only have one entry for each unique
# combination of name/email/phone/address, de-duping that person's tags as we go
personal_info_mapped_to_tags = Hash.new { |hash, key| hash[key] = [] }
table.by_row!
table.each do |row|
  key = [row["First Name"], row["Last Name"], row["Email Address"], row["Phone"], row["Address"]]
  personal_info_mapped_to_tags[key].concat(row["Tags"]).uniq!
end

output_string = CSV.generate do |csv|
  csv << ["First Name", "Last Name", "Email Address", "Phone", "Address", "Tags"]
  personal_info_mapped_to_tags.each_pair do |personal_info, tags|
    formatted_tags_field = tags.map(&:inspect).join(",")
    csv << personal_info.push(formatted_tags_field)
  end
end

puts output_string.to_s

warn "Done.\n\n"
# TODO we can probably downcase everything when comparing for uniqueness (but
# careful, currently the keys ARE the data so we would need to separate that
# out)
# TODO the true unique value for MailChimp is the email address; this could
# resolve the collisions in the rest of the data.
