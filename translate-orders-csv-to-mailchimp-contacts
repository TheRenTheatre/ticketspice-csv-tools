#!/usr/bin/env ruby -w
# frozen_string_literal: true

require 'csv'
require 'date'
require 'time'
require 'awesome_print'
require 'active_support/core_ext/object/inclusion'

REQUIRED_TICKETSPICE_FIELDS = ["Order Number",
                               "Date Completed",
                               "Page Name",
                               "Date Selection",
                               "Timeslot Selection",
                               "Billing Name (First Name)",
                               "Billing Name (Last Name)",
                               "Billing Email Address",
                               "Billing Phone Number",
                               "Billing Address (Address 1)",
                               "Billing Address (Address 2)",
                               "Billing Address (City)",
                               "Billing Address (State/Province)",
                               "Billing Address (Country)",
                               "Billing Address (Postal Code)"]

                               # TODO check for the two other Phone Number
                               # fields and the four versions of the
                               # "Added Donation ($ Amount)" field.

def warn_usage_and_abort
  list_of_fields = [REQUIRED_TICKETSPICE_FIELDS.map(&:inspect) + ['"Added Donation (Amount)" columns']]
  warn "\nUsage: #{$0} path/to/orders.csv\n\n" +
       "Required fields:\n" +
        "  - " + list_of_fields.join("\n  - ") + "\n\n"
  exit 1
end

warn_usage_and_abort unless ARGV.length == 1


def tags_to_apply(page_name, date_selection, timeslot_selection, date_completed, added_donation_amount, csv_row)
  tags = []
  if date_selection.nil? # one-off events
    date = year = nil
  else
    date = Date.parse(date_selection)
    year = date.year
  end

  if page_name == "Nosferatu" && year == 2021
    tags << "Patrons - 2021 - Nosferatu, Entire Run"
    tags << case date
            when Date.parse("2021-10-01")..Date.parse("2021-10-02")
              "Patrons - 2021 - Nosferatu, 1st Week"
            when Date.parse("2021-10-08")..Date.parse("2021-10-09")
              "Patrons - 2021 - Nosferatu, 2nd Week"
            when Date.parse("2021-10-15")..Date.parse("2021-10-16")
              "Patrons - 2021 - Nosferatu, 3rd Week"
            when Date.parse("2021-10-22")..Date.parse("2021-10-23")
              "Patrons - 2021 - Nosferatu, 4th Week"
            when Date.parse("2021-10-28")..Date.parse("2021-10-31")
              "Patrons - 2021 - Nosferatu, 5th Week"
            when Date.parse("2021-11-05")..Date.parse("2021-11-06")
              "Patrons - 2021 - Nosferatu, 6th Week"
            else raise "Unknown show date for Nosferatu: #{date}"
            end

  elsif page_name == "The Office Holiday Party Musical Extravaganza Show" && year == 2021
    tags << "Patrons - 2021 - The Office Holiday Party Musical Extravaganza Show, Entire Run"
    tags << case date
            when Date.parse("2021-12-02")..Date.parse("2021-12-05")
              "Patrons - 2021 - The Office Holiday Party Musical Extravaganza Show, 1st Week"
            when Date.parse("2021-12-09")..Date.parse("2021-12-12")
              "Patrons - 2021 - The Office Holiday Party Musical Extravaganza Show, 2nd Week"
            when Date.parse("2021-12-16")..Date.parse("2021-12-19")
              "Patrons - 2021 - The Office Holiday Party Musical Extravaganza Show, 3rd Week"
            else raise "Unknown show date for Office Party: #{date}"
            end

  elsif page_name =~ /^Dickens by Candl?elight$/ && year == 2021
    # It was misspelled "Candelight" in Ticketspice
    tags << "Patrons - 2021 - Dickens by Candlelight, Entire Run"

  elsif page_name == "La Medéa" && year == 2022
    tags << "Patrons - 2022 - La Medéa, Entire Run"
    tags << case date
            when Date.parse("2022-01-21")..Date.parse("2022-01-23")
              "Patrons - 2022 - La Medéa, 1st Week"
            when Date.parse("2022-01-28")..Date.parse("2022-01-30")
              "Patrons - 2022 - La Medéa, 2nd Week"
            when Date.parse("2022-02-04")..Date.parse("2022-02-06")
              "Patrons - 2022 - La Medéa, 3rd Week"
            when Date.parse("2022-02-10")..Date.parse("2022-02-13")
              "Patrons - 2022 - La Medéa, 4th Week"
            else raise "Unknown show date for La Medéa: #{date}"
            end

  elsif page_name == "Stephen Pugh in Concert"
    # One-off event: Feb 9 2022 at 8 PM
    year = 2022
    tags << "Patrons - 2022 - Stephen Pugh in Concert"

  elsif page_name == "Laurel Hatfield in Concert"
    # One-off event: Feb 22 2022 at 8 PM
    year = 2022
    tags << "Patrons - 2022 - Laurel Hatfield in Concert"

  elsif page_name == "Oscar Wilde and Jesus Christ Walk Into a Gay Bar" && year == 2022
    tags << "Patrons - 2022 - Oscar Wilde and Jesus Christ Walk Into a Gay Bar, Entire Run"
    tags << case date
            when Date.parse("2022-02-20")
              "Patrons - 2022 - Oscar Wilde and Jesus Christ Walk Into a Gay Bar, 1st Week"
            when Date.parse("2022-02-27")
              "Patrons - 2022 - Oscar Wilde and Jesus Christ Walk Into a Gay Bar, 2nd Week"
            when Date.parse("2022-03-06")
              "Patrons - 2022 - Oscar Wilde and Jesus Christ Walk Into a Gay Bar, 3rd Week"
            when Date.parse("2022-03-13")
              "Patrons - 2022 - Oscar Wilde and Jesus Christ Walk Into a Gay Bar, 4th Week"
            when Date.parse("2022-03-20")
              "Patrons - 2022 - Oscar Wilde and Jesus Christ Walk Into a Gay Bar, 5th Week"
            when Date.parse("2022-03-27")
              warn "  - warning: we cancelled the Mar 27, 2022 show of Oscar Wilde, but there's a completed order for it:\n" +
                   "             #{printable_order_summary(csv_row)}\n\n"
              nil
            when Date.parse("2022-04-03")
              warn "  - warning: we cancelled the Apr 3, 2022 show of Oscar Wilde, but there's a completed order for it:\n" +
                   "             #{printable_order_summary(csv_row)}\n\n"
              nil
            when Date.parse("2022-04-10")
              "Patrons - 2022 - Oscar Wilde and Jesus Christ Walk Into a Gay Bar, 8th Week"
            else raise "Unknown show date for Oscar Wilde and Jesus Christ Walk Into a Gay Bar: #{date}"
            end

  elsif page_name == "Gorgeous" && year == 2022
    tags << "Patrons - 2022 - Gorgeous, Entire Run"
    tags << case date
            when Date.parse("2022-03-04")..Date.parse("2022-03-06")
              "Patrons - 2022 - Gorgeous, 1st Week"
            when Date.parse("2022-03-11")..Date.parse("2022-03-13")
              "Patrons - 2022 - Gorgeous, 2nd Week"
            when Date.parse("2022-03-18")..Date.parse("2022-03-20")
              "Patrons - 2022 - Gorgeous, 3rd Week"
            when Date.parse("2022-03-25")..Date.parse("2022-03-27")
              "Patrons - 2022 - Gorgeous, 4th Week"
            when Date.parse("2022-03-31")..Date.parse("2022-04-03")
              "Patrons - 2022 - Gorgeous, 5th Week"
            when Date.parse("2022-04-07")..Date.parse("2022-04-10")
              warn "  - warning: we cancelled the 6th week of Gorgeous, but there's a completed order for it:\n" +
                   "             #{printable_order_summary(csv_row)}\n\n"
              nil
            else raise "Unknown show date for Gorgeous: #{date}"
            end

  elsif page_name == "Ain't Done Bad" && year == 2022
    tags << "Patrons - 2022 - Ain't Done Bad, Entire Run"
    tags << case date
            when Date.parse("2022-04-23")
              if timeslot_selection == "9:00 PM"
                warn "  - warning: we cancelled the 9 PM show of Ain't Done Bad on 4/23/2022, but there's a completed order for it:\n" +
                     "             #{printable_order_summary(csv_row)}\n\n"
                nil
              elsif timeslot_selection == "7:00 PM"
                "Patrons - 2022 - Ain't Done Bad, 1st Week"
              else
                raise "Unknown show time for Ain't Done Bad: #{timeslot_selection} on #{date}"
              end
            when Date.parse("2022-04-21")..Date.parse("2022-04-24")
              "Patrons - 2022 - Ain't Done Bad, 1st Week"
            when Date.parse("2022-04-27")..Date.parse("2022-05-01")
              "Patrons - 2022 - Ain't Done Bad, 2nd Week"
            else raise "Unknown show date for Ain't Done Bad: #{date}"
            end

  elsif page_name == "From Here: In Concert" && year == 2022
    # One weekend, but let's use "Entire Run" since it was three performances
    tags << "Patrons - 2022 - From Here: In Concert, Entire Run"

  elsif page_name == "Bullock and the Bandits" && year == 2022
    tags << "Patrons - 2022 - Bullock and the Bandits, All Shows"
    tags << case date
            when Date.parse("2022-07-01")
              "Patrons - 2022 - Bullock and the Bandits, Jul 1"
            when Date.parse("2022-10-05")
              "Patrons - 2022 - Bullock and the Bandits, Oct 5"
            when Date.parse("2022-10-12")
              "Patrons - 2022 - Bullock and the Bandits, Oct 12"
            when Date.parse("2022-10-19")
              "Patrons - 2022 - Bullock and the Bandits, Oct 19"
            else raise "Unknown show date for #{page_name}: #{date}"
            end

  elsif page_name == "Spooky & Gay" && year == 2022
    # Single show, but not set up in TicketSpice as a one-off event
    tags << "Patrons - 2022 - Spooky & Gay"

  elsif page_name == "Lenox Ave" && year == 2022
    tags << "Patrons - 2022 - Lenox Ave, Entire Run"
    tags << case date
            when Date.parse("2022-07-22")..Date.parse("2022-07-23")
              "Patrons - 2022 - Lenox Ave, 1st Week"
            when Date.parse("2022-07-29")..Date.parse("2022-07-30")
              "Patrons - 2022 - Lenox Ave, 2nd Week"
            when Date.parse("2022-08-05")..Date.parse("2022-08-06")
              "Patrons - 2022 - Lenox Ave, 3rd Week"
            when Date.parse("2022-08-12")..Date.parse("2022-08-14")
              "Patrons - 2022 - Lenox Ave, 4th Week"
            else raise "Unknown show date for Lenox Ave: #{date}"
            end

  elsif page_name == "Nosferatu" && year == 2022
    tags << "Patrons - 2022 - Nosferatu, Entire Run"
    tags << case date
            when Date.parse("2022-09-23")..Date.parse("2022-09-24")
              "Patrons - 2022 - Nosferatu, 1st Week"
            when Date.parse("2022-09-30")..Date.parse("2022-10-01")
              "Patrons - 2022 - Nosferatu, 2nd Week"
            when Date.parse("2022-10-07")..Date.parse("2022-10-08")
              "Patrons - 2022 - Nosferatu, 3rd Week"
            when Date.parse("2022-10-14")..Date.parse("2022-10-15")
              "Patrons - 2022 - Nosferatu, 4th Week"
            when Date.parse("2022-10-21")..Date.parse("2022-10-22")
              "Patrons - 2022 - Nosferatu, 5th Week"
            when Date.parse("2022-10-27")..Date.parse("2022-10-31")
              "Patrons - 2022 - Nosferatu, 6th Week"
            when Date.parse("2022-11-03")..Date.parse("2022-11-05")
              "Patrons - 2022 - Nosferatu, 7th Week"
            else raise "Unknown show date for Nosferatu: #{date}"
            end

  elsif page_name == "MX OTR The Pageant Experience" && year == 2022
    # Single show, but not set up in TicketSpice as a one-off event
    tags << "Patrons - 2022 - OTR"

  elsif page_name == "Winnie's Rock Cauldron Cabaret" && year == 2022
    # Single show, but not set up in TicketSpice as a one-off event
    tags << "Patrons - 2022 - Winnie's Rock Cauldron Cabaret"

  elsif page_name == "A Halloween Carol" && year == 2022
    # Single show, but not set up in TicketSpice as a one-off event
    tags << "Patrons - 2022 - A Halloween Carol"

  elsif page_name == "Hexed A Femme Rock Musical" && year == 2022
    tags << "Patrons - 2022 - Hexed, Entire Run"

  elsif page_name == "ASL Slam" && (year == 2022 || year == 2023)
    # Two single shows, not really sure how to tag these yet so we'll just keep with the year for now
    tags << "Patrons - #{year} - ASL Slam"

  elsif page_name == "ASL Slam 3" && year.nil?
    year = 2023
    tags << "Patrons - 2023 - ASL Slam"

  elsif page_name == "ASL Slam 4" && year.nil?
    # Set up as one-off event on Friday, Nov 17, 2023
    year = 2023
    tags << "Patrons - 2023 - ASL Slam"

  elsif page_name == "ASL Slam 5" && year.nil?
    # Set up as one-off event on Sat, Mar 16, 2024
    year = 2024
    tags << "Patrons - 2024 - ASL Slam"

  elsif page_name == "ASL Slam 6" && year.nil?
    # Set up as one-off event on Sat, Jun 1, 2024
    year = 2024
    tags << "Patrons - 2024 - ASL Slam"

  elsif page_name == "The Office Holiday Party Musical Extravaganza Show" && year == 2022
    tags << "Patrons - 2022 - The Office Holiday Party Musical Extravaganza Show, Entire Run"
    tags << case date
            when Date.parse("2022-12-01")..Date.parse("2022-12-03")
              "Patrons - 2022 - The Office Holiday Party Musical Extravaganza Show, 1st Week"
            when Date.parse("2022-12-08")..Date.parse("2022-12-10")
              "Patrons - 2022 - The Office Holiday Party Musical Extravaganza Show, 2nd Week"
            when Date.parse("2022-12-15")..Date.parse("2022-12-17")
              "Patrons - 2022 - The Office Holiday Party Musical Extravaganza Show, 3rd Week"
            when Date.parse("2022-12-22")..Date.parse("2022-12-23")
              "Patrons - 2022 - The Office Holiday Party Musical Extravaganza Show, 4th Week"
            else raise "Unknown show date for Office Party: #{date}"
            end

  elsif page_name == "Black & White Night" && year == 2022
    # Single event, but not set up in TicketSpice as a one-off event
    tags << "Patrons - 2022 - Black & White Night"

  elsif page_name == "6 Guitars" && year == 2023
    tags << "Patrons - 2023 - 6 Guitars, Entire Run"
    tags << case date
            when Date.parse("2023-01-06")..Date.parse("2023-01-07")
              "Patrons - 2023 - 6 Guitars, 1st Week"
            when Date.parse("2023-01-13")..Date.parse("2023-01-14")
              "Patrons - 2023 - 6 Guitars, 2nd Week"
            when Date.parse("2023-01-20")..Date.parse("2023-01-21")
              "Patrons - 2023 - 6 Guitars, 3rd Week"
            when Date.parse("2023-01-27")..Date.parse("2023-01-29")
              "Patrons - 2023 - 6 Guitars, 4th Week"
            else raise "Unknown show date for 6 Guitars: #{date}"
            end

  elsif page_name == "From Here: In Orlando" && year == 2023
    # Two shows on one day; sanity check for future similar show names
    raise "Unexpected date for #{page_name}: #{date}" unless date == Date.parse("2023-01-17")
    tags << "Patrons - 2023 - From Here: In Orlando"

  elsif (page_name == "The Ren Sings" || page_name == "The Ren Sings Dolly") && year == 2023
    # Intermittent series; make sure we catch any future shows
    tags << "Patrons - 2023 - The Ren Sings, All"
    if date == Date.parse("2023-02-18")
      tags << "Patrons - 2023 - The Ren Sings Mariah Carey"
    elsif date == Date.parse("2023-03-31")
      tags << "Patrons - 2023 - The Ren Sings Celine Dion"
    elsif date == Date.parse("2023-05-03")
      tags << "Patrons - 2023 - The Ren Sings Dolly Parton"
    else
      raise "Unexpected date for #{page_name}: #{date}"
    end

  elsif page_name == "The Ren Sings Whitney Houston" && date.in?(Date.new(2023, 6, 28)..Date.new(2023, 6, 29))
    tags << "Patrons - 2023 - The Ren Sings, All"
    tags << "Patrons - 2023 - The Ren Sings Whitney Houston"

  elsif page_name == "Monster Cabaret" && year == 2023
    # Single show; catch any future shows in the series
    raise "Unexpected date for #{page_name}: #{date}" unless date == Date.parse("2023-02-25")
    tags << "Patrons - 2023 - Monster Cabaret"

  elsif page_name == "Beacon Street: A New Musical" && year == 2023
    # Two show run; catch future runs
    raise "Unexpected date for #{page_name}: #{date}" unless date.in?(Date.parse("2023-02-24")..Date.parse("2023-02-25"))
    tags << "Patrons - 2023 - Beacon Street: A New Musical"

  elsif page_name == "Josephine" && year == 2023
    tags << "Patrons - 2023 - Josephine, Entire Run"
    tags << case date
            when Date.parse("2023-03-09")..Date.parse("2023-03-12")
              "Patrons - 2023 - Josephine, 1st Week"
            when Date.parse("2023-03-16")..Date.parse("2023-03-19")
              "Patrons - 2023 - Josephine, 2nd Week"
            else raise "Unknown show date for Josephine: #{date}"
            end

  elsif page_name == "Sincerely, Three: Live at The Ren" && year == 2023
    # Single performance, but not set up in TicketSpice as a one-off event;
    # catch any future shows
    raise "Unexpected date for #{page_name}: #{date}" unless date == Date.parse("2023-03-01")
    tags << "Patrons - 2023 - Sincerely, Three: Live at The Ren"

  elsif (page_name == "Sessions at the Ren" || page_name == "Sessions 2.0") && year == 2023
    # Ongoing series, three shows so far, keep them together for now
    raise "Unexpected date for #{page_name}: #{date}" unless date.in?([Date.parse("2023-03-04"), Date.parse("2023-04-19")])
    tags << "Patrons - 2023 - Sessions at the Ren"

  elsif page_name == "Sessions 3" && year.nil?
    # June 7, 2023 at 7 PM
    year = 2023
    tags << "Patrons - 2023 - Sessions at the Ren"

  elsif page_name == "Circles of Hell: A Staged Workshop" && year == 2023
    # Two show run
    raise "Unexpected date for #{page_name}: #{date}" unless date.in?(Date.parse("2023-03-24")..Date.parse("2023-03-25"))
    tags << "Patrons - 2023 - Circles of Hell: A Staged Workshop"

  elsif page_name == "Mood" && year == 2023
    # Ongoing series, but only one so far; catch any future shows to maybe tag
    # differently
    raise "Unexpected date for #{page_name}: #{date}" unless date == Date.parse("2023-03-25")
    tags << "Patrons - 2023 - Mood"

  elsif page_name =~ /^Mood( [34])?$/ && year.nil?
    year = 2023
    # Like so. This catches Mood 2–4
    tags << "Patrons - 2023 - Mood"

  elsif page_name =~ /^Ren +@ +Ren$/ && year.nil?
    # "Renaissance @ Renaissance" was the Beyoncé-themed Mood/OTR on Aug 23, 2023
    year = 2023
    tags << "Patrons - 2023 - Mood"

  elsif page_name == "Mood Proud" && year.nil?
    # Mood after Pride on Oct 21, 2023
    year = 2023
    tags << "Patrons - 2023 - Mood"

  elsif page_name == "Titan After Party" && year == 2023
    tags << "Patrons - 2023 - Dragula Titans Tour After-Party"

  elsif page_name == "The Cocaine Play" && year == 2023
    tags << "Patrons - 2023 - The Cocaine Play, Entire Run"
    tags << case date
            when Date.parse("2023-04-13")
              warn "  - warning: we moved the Apr 13, 2023 show of The Cocaine Play, but there's a completed order for it:\n" +
                   "             #{printable_order_summary(csv_row)}\n\n"
              nil
            when Date.parse("2023-04-14")..Date.parse("2023-04-15")
              "Patrons - 2023 - The Cocaine Play, 1st Week"
            when Date.parse("2023-04-20")..Date.parse("2023-04-22")
              "Patrons - 2023 - The Cocaine Play, 2nd Week"
            when Date.parse("2023-04-27")..Date.parse("2023-04-29")
              "Patrons - 2023 - The Cocaine Play, 3rd Week"
            when Date.parse("2023-05-04")..Date.parse("2023-05-06")
              "Patrons - 2023 - The Cocaine Play, 4th Week"
            else raise "Unknown show date for The Cocaine Play: #{date}"
            end

  elsif (page_name == "Ren Fair Merchants" || page_name == "Outside Ren Fair Merchants") && year == 2023
    tags << "Vendors - 2023 - Renaissance Fair"

  elsif page_name == "I Love Liz" && year.nil?
    # One-off event: Apr 18 2023 at 8 PM
    year = 2023
    tags << "Patrons - 2023 - I Love Liz"

  elsif page_name == "Cabaret Superstar 2023" && year.nil?
    # Event series: Apr 3, Apr 10, Apr 17, Apr 24, and May 1, 2023
    year = 2023
    tags << "Patrons - 2023 - Musical Mondays"

  elsif page_name == "Gay Bar Star" && year.nil?
    # One-off event: Jul 27, 2023
    year = 2023
    tags << "Patrons - 2023 - Gay Bar Star"

  elsif (page_name == "54" || page_name == "54 Upgrades") && year == 2023
    tags << "Patrons - 2023 - 54, Entire Run"
    tags << case date
      when Date.parse("2023-06-23")..Date.parse("2023-06-24")
        "Patrons - 2023 - 54, 1st Week"
      when Date.parse("2023-06-30")..Date.parse("2023-07-01")
        "Patrons - 2023 - 54, 2nd Week"
      when Date.parse("2023-07-07")..Date.parse("2023-07-09")
        "Patrons - 2023 - 54, 3rd Week"
      when Date.parse("2023-07-14")..Date.parse("2023-07-16")
        "Patrons - 2023 - 54, 4th Week"
      when Date.parse("2023-07-21")..Date.parse("2023-07-22")
        "Patrons - 2023 - 54, 5th Week"
      when Date.parse("2023-07-28")..Date.parse("2023-07-29")
        "Patrons - 2023 - 54, 6th Week"
      when Date.parse("2023-08-04")..Date.parse("2023-08-05")
        "Patrons - 2023 - 54, 7th Week"
      when Date.parse("2023-08-11")..Date.parse("2023-08-12")
        "Patrons - 2023 - 54, 8th Week"
      when Date.parse("2023-08-18")..Date.parse("2023-08-19")
        "Patrons - 2023 - 54, 9th Week"
      when Date.parse("2023-08-25")..Date.parse("2023-08-26")
        "Patrons - 2023 - 54, 10th Week"
      else raise "Unknown show date for 54: #{date}"
      end

  elsif page_name == "You Like Jazz?" && year.nil?
    # One-off event: Sep 17, 2023
    year = 2023
    tags << "Patrons - 2023 - You Like Jazz?"

  elsif page_name == "Gagaball" && year.nil?
    # One-off event: Sep 21, 2023
    year = 2023
    tags << "Patrons - 2023 - Gagaball"

  elsif page_name == "Monday Please!" && year == 2023
    # This was used to process a donation for our fundraiser on Oct 2, 2023
    tags << "Donors - 2023"

  elsif page_name == "MX OTR Pageant" && year.nil?
    # One-off event: Oct 4, 2023
    year = 2023
    tags << "Patrons - 2023 - OTR"

  elsif page_name.in?(["Nosf3ratu", "Nosf3ratu Upgrades"]) && year == 2023
    tags << "Patrons - 2023 - Nosferatu, Entire Run"
    tags << case date
      when Date.parse("2023-09-15")..Date.parse("2023-09-16")
        "Patrons - 2023 - Nosferatu, 1st Week"
      when Date.parse("2023-09-22")..Date.parse("2023-09-23")
        "Patrons - 2023 - Nosferatu, 2nd Week"
      when Date.parse("2023-09-29")..Date.parse("2023-09-30")
        "Patrons - 2023 - Nosferatu, 3rd Week"
      when Date.parse("2023-10-06")..Date.parse("2023-10-07")
        "Patrons - 2023 - Nosferatu, 4th Week"
      when Date.parse("2023-10-13")..Date.parse("2023-10-14")
        "Patrons - 2023 - Nosferatu, 5th Week"
      when Date.parse("2023-10-19")..Date.parse("2023-10-22")
        "Patrons - 2023 - Nosferatu, 6th Week"
      when Date.parse("2023-10-26")..Date.parse("2023-10-31")
        "Patrons - 2023 - Nosferatu, 7th Week"
      when Date.parse("2023-11-02")..Date.parse("2023-11-05")
        "Patrons - 2023 - Nosferatu, 8th Week"
      else raise "Unknown show date for Nosferatu: #{date}"
      end

  elsif page_name =~ /^The Office Holiday Party Musical Extravaganza Show( 3)?$/ && year == 2023
    tags << "Patrons - 2023 - The Office Holiday Party Musical Extravaganza Show, Entire Run"
    tags << case date
            when Date.parse("2023-11-30")..Date.parse("2023-12-03")
              "Patrons - 2023 - The Office Holiday Party Musical Extravaganza Show, 1st Week"
            when Date.parse("2023-12-07")..Date.parse("2023-12-10")
              "Patrons - 2023 - The Office Holiday Party Musical Extravaganza Show, 2nd Week"
            when Date.parse("2023-12-14")..Date.parse("2023-12-18")
              "Patrons - 2023 - The Office Holiday Party Musical Extravaganza Show, 3rd Week"
            when Date.parse("2023-12-20")..Date.parse("2023-12-23")
              "Patrons - 2023 - The Office Holiday Party Musical Extravaganza Show, 4th Week"
            else raise "Unknown show date for Office Holiday Party: #{date}"
            end

  elsif page_name == "Musical Mondays Sings Legally Blonde" && year.nil?
    # Nov 20, 2023
    year = 2023
    tags << "Patrons - 2023 - Musical Mondays"

  elsif page_name == "Musical Mondays Sings Annie" && year.nil?
    # Dec 18, 2023
    year = 2023
    tags << "Patrons - 2023 - Musical Mondays"

  elsif page_name == "Qualia" && year == 2024
    raise "Unknown show date for Qualia: #{date}" unless date.in?(Date.new(2024, 1, 26)..Date.new(2024, 2, 11))
    tags << "Patrons - 2024 - Qualia"

  elsif (page_name == "Milk" || page_name == "MILK") && year == 2024
    raise "Unknown show date for Milk: #{date}" unless date.in?(
      (Date.new(2024, 2, 22)..Date.new(2024, 3, 10)).to_a +
       [Date.new(2024, 3, 17), Date.new(2024, 3, 24), Date.new(2024, 3, 31)])
    tags << "Patrons - 2024 - Milk"

  elsif page_name == "The Ren" && year.nil?
    # This is our hacky standalone page for gift certificates
    year = 2024

  elsif page_name == "thank u, next" && year == 2024
    # Two OTR events: Feb 14 and Feb 21
    raise "Unknown show date for 'thank u, next': #{date}" unless date.in?([Date.new(2024, 2, 14), Date.new(2024, 2, 21)])
    tags << "Patrons - 2024 - OTR"

  elsif page_name == "Quickies" && year == 2024
    raise "Unknown show date for Quickies: #{date}" unless
      date.in?(Date.new(2024, 2, 14)..Date.new(2024, 2, 18))
    tags << "Patrons - 2024 - Quickies"

  elsif page_name == "From Here" && year == 2024
    # This is the March-May 2024 run at the Ren
    tags << "Patrons - 2024 - From Here at the Ren, Entire Run"

  elsif page_name == "Ren Events Vendors" && year == 2024
    tags << "Vendors - 2024"

  elsif page_name == "Renburn" && year.nil?
    # One-off event on Saturday, Feb 17 2024 for our 3rd anniversary
    year = 2024
    tags << "Patrons - 2024 - Renburn"

  elsif page_name == "Renburn" && year == 2024
    # Sequel events that are also the Saturday after-parties for Milk
    raise "Unknown show date for Renburn: #{date}" unless
      date.in?([Date.new(2024, 2, 24), Date.new(2024, 3, 2), Date.new(2024, 3, 9)])
    tags << "Patrons - 2024 - Renburn"

  elsif page_name == "act ii Listening Party" && year == 2024
    # One-off event on Thu, Mar 28 2024 for Beyoncé's record release
    tags << "Patrons - 2024 - act ii Listening Party"

  elsif page_name == "Cesar's Birthday Bash" && year.nil?
    # One-off event on Fri, Mar 15, 2024
    year = 2024
    tags << "Patrons - 2024 - Cesar's Birthday Bash"

  elsif page_name == "The Afters" && year == 2024
    # The Saturdays after From Here starting with the second week
    dates = 8.times.map { |week| Date.new(2024, 3, 30) + week * 7 }
    raise "Unknown show date for The Afters: #{date}" unless date.in?(dates)
    tags << "Patrons - 2024 - The Afters"

  elsif page_name == "Musical Mondays" && year == 2024
    # We started selling advance tickets for MM using a single page in April 2024
    mondays_in_2024 = 40.times.map { |week| Date.new(2024, 4, 1) + week * 7 }
    raise "Unknown show date for Musical Mondays: #{date}" unless date.in?(mondays_in_2024)
    tags << "Patrons - 2024 - Musical Mondays"

  elsif page_name == "The Ren Dances" && year == 2024
    # Dance classes from 4/17
    ren_dances_dates = [Date.new(2024, 4, 17), Date.new(2024, 4, 24), Date.new(2024, 5, 1), Date.new(2024, 5, 8)]
    raise "Unknown date for The Ren Dances: #{date}" unless date.in?(ren_dances_dates)
    tags << "Patrons - 2024 - The Ren Dances"

  elsif page_name =~ /^'?24$/ && year == 2024
    tags << "Patrons - 2024 - 24, Entire Run"
    tags << case date
      when Date.parse("2023-06-08")..Date.parse("2024-06-13")
        warn "  - warning: we moved the #{date} show of '24, but there's a completed order for it:\n" +
             "             #{printable_order_summary(csv_row)}\n\n"
        nil
      when Date.parse("2024-06-08")..Date.parse("2024-06-09")
        "Patrons - 2024 - 24, cancelled 1st Week"
      when Date.parse("2024-06-14")..Date.parse("2024-06-15")
        "Patrons - 2024 - 24, 1st Week"
      when Date.parse("2024-06-21")..Date.parse("2024-06-22")
        "Patrons - 2024 - 24, 2nd Week"
      when Date.parse("2024-06-26")..Date.parse("2024-06-27")
        "Patrons - 2024 - 24, 3rd Week"
      when Date.parse("2024-07-05")..Date.parse("2024-07-06")
        "Patrons - 2024 - 24, 4th Week"
      when Date.parse("2024-07-11")..Date.parse("2024-07-14")
        "Patrons - 2024 - 24, 5th Week"
      when Date.parse("2024-07-18")..Date.parse("2024-07-21")
        "Patrons - 2024 - 24, 6th Week"
      when Date.parse("2024-07-25")..Date.parse("2024-07-28")
        "Patrons - 2024 - 24, 7th Week"
      when Date.parse("2024-08-01")..Date.parse("2024-08-04")
        "Patrons - 2024 - 24, 8th Week"
      when Date.parse("2024-08-08")..Date.parse("2024-08-11")
        "Patrons - 2024 - 24, 9th Week"
      else raise "Unknown show date for 24: #{date}"
      end

  elsif page_name == "Funny Gworl!" && year.nil?
    # One-off event on Thu, May 2, 2024
    year = 2024
    tags << "Patrons - 2024 - Funny Gworl"

  elsif page_name == "Orlando Fringe BYOV Teaser Show" && year.nil?
    # One-off event on Mon, May 6, 2024
    year = 2024
    tags << "Patrons - 2024 - Orlando Fringe BYOV Teaser Show"

  elsif page_name == "Club Kid Fantasy" && year.nil?
    # One-off event alongside OTR on Wed, May 22, 2024
    year = 2024
    tags << "Patrons - 2024 - OTR"

  elsif page_name == "OTR: club brat" && year == 2024
    # A few weeks of OTR in July, 2024
    dates = [Date.new(2024, 7, 3), Date.new(2024, 7, 10)]
    raise "Unknown show date for OTR: club brat: #{date}" unless date.in?(dates)
    tags << "Patrons - 2024 - OTR"

  elsif page_name == "OTR: Sapphic Summer" && year == 2024
    raise "Unknown show date for OTR: Sapphic Summer: #{date}" unless date == Date.new(2024, 7, 24)
    tags << "Patrons - 2024 - OTR"

  elsif page_name == "Nosferatu" && year == 2024
    tags << "Patrons - 2024 - Nosferatu, Entire Run"
    tags << case date
      when Date.parse("2024-09-13")..Date.parse("2024-09-14")
        "Patrons - 2024 - Nosferatu, 1st Week"
      when Date.parse("2024-09-20")..Date.parse("2024-09-21")
        "Patrons - 2024 - Nosferatu, 2nd Week"
      when Date.parse("2024-09-27")..Date.parse("2024-09-28")
        "Patrons - 2024 - Nosferatu, 3rd Week"
      when Date.parse("2024-10-03")..Date.parse("2024-10-05")
        "Patrons - 2024 - Nosferatu, 4th Week"
      when Date.parse("2024-10-10")..Date.parse("2024-10-12")
        "Patrons - 2024 - Nosferatu, 5th Week"
      when Date.parse("2024-10-16")..Date.parse("2024-10-20")
        "Patrons - 2024 - Nosferatu, 6th Week"
      when Date.parse("2024-10-23")..Date.parse("2024-10-27")
        "Patrons - 2024 - Nosferatu, 7th Week"
      when Date.parse("2024-10-28")..Date.parse("2024-11-03")
        "Patrons - 2024 - Nosferatu, 8th Week"
      when Date.parse("2024-11-07")..Date.parse("2024-11-10")
        "Patrons - 2024 - Nosferatu, 9th Week"
      else raise "Unknown show date for 24: #{date}"
      end


  else
    warn "\n\n\n"
    raise "No handler for Page Name #{page_name.inspect} and year #{year.inspect} (parsed from #{date_selection.inspect})\n\n\n"
  end

  # TODO: if someone buys tickets for a future show, is imported as e.g. "Week
  # 3", then changes their tickets to "Week 2" and is imported again, they'll
  # end up tagged with both in Mailchimp. Once this is API-based we could remove
  # the incorrect tags, but there's no way to do that through a CSV. A quick fix
  # would be to leave them out of the show tags until the show has happened, at
  # the expense of not being able to target future patrons for a certain show
  # via Mailchimp alone.

  raise "Error: year wasn't set for order: #{printable_order_summary(csv_row)}" if year.nil?

  if added_donation_amount > 0
    tags << "Donors - #{date_completed.year}"
  end

  tags.compact!

  tags
end

def printable_order_summary(row)
  values = row.to_h.fetch_values("First Name", "Last Name", "Order Number", "Page Name", "Date Selection")
  values[4] ||= "(no date)"
  "%s %s - order number %s - tickets for '%s' on %s" % values
end

def mailchimp_style_combined_address_field_for_row(row)
  # Docs: https://mailchimp.com/help/import-mailing-addresses-postcards/
  columns = [row["Address - Street Address"],
             row["Address - Address Line 2"],
             row["Address - City"],
             row["Address - State/Prov/Region"],
             row["Address - Zip/Postal"],
             row["Address - Country"]]
  columns.compact!
  columns.map! { |col|
    col.strip.gsub(/\s{2,}/, " ")
  }
  joined = columns.join("  ")

  return nil if joined.strip.empty?
  joined
end

col_num = 0
ticketspice_to_mailchimp_converter = proc { |ticketspice_header|
  translation = Hash.new { |h, key| h[key] = key; key }
  translation.merge!(
    "Billing Name (First Name)"        => "First Name",
    "Billing Name (Last Name)"         => "Last Name",
    "Billing Email Address"            => "Email Address",
    "Billing Phone Number"             => "Phone #{col_num}",
    "Phone Number"                     => "Phone #{col_num}",
    "Billing Address (Address 1)"      => "Address - Street Address",
    "Billing Address (Address 2)"      => "Address - Address Line 2",
    "Billing Address (City)"           => "Address - City",
    "Billing Address (State/Province)" => "Address - State/Prov/Region",
    "Billing Address (Country)"        => "Address - Country",
    "Billing Address (Postal Code)"    => "Address - Zip/Postal",
    "Added Donation ($ Amount)"        => "Added Donation (Amount) #{col_num}",
    "Donation Amount ($ Amount)"       => "Added Donation (Amount) #{col_num}"
  )
  col_num += 1
  translation[ticketspice_header]
}

file_contents = File.read(ARGV[0], encoding: 'bom|utf-8')

# Make sure we have all the fields we need
header_test_csv = CSV.parse(file_contents.lines.first, headers: true)
missing_headers = REQUIRED_TICKETSPICE_FIELDS.sort - header_test_csv.headers.sort
if missing_headers.any?
  warn "\n\nYour orders report is missing these required fields: #{missing_headers.inspect}"
  warn_usage_and_abort
end


# Parse whole file and rename headers to Mailchimp's names
table = CSV.parse(file_contents, headers: true,
                                 header_converters: ticketspice_to_mailchimp_converter)

# Collapse duplicate fields; convert mailing address; add tags
table.each do |row|
  added_donation_amount = row.map { |col, value|
    value.to_f if col.start_with?("Added Donation (Amount)")
  }.compact.sum

  phones = row.map { |col, value|
    if col.start_with?("Phone")
      if value =~ /^1(\d{3})(\d{3})(\d{4})$/
        "(%s) %s-%s" % Regexp.last_match[1..3]
      else
        value
      end
    else
      nil
    end
  }.compact.uniq
  warn "  - warning: more than one Phone for order #{row["Order Number"].inspect}: #{phones.inspect}" if phones.count > 1
  row["Phone"] = phones.first

  # TODO: these values don't mention a TZ. They look like local time, which is
  # usually the same as this machine (America/New_York), so this works anyway for
  # us, but we should pull that in from somewhere.
  date_completed = Time.parse(row["Date Completed"])

  tags = tags_to_apply(row["Page Name"], row["Date Selection"], row["Timeslot Selection"],
                       date_completed, added_donation_amount, row)
  row["Address"] = mailchimp_style_combined_address_field_for_row(row)
  row["Tags"] = tags
end


# Skip rows without an email address - typically at-door box office sales
if table.any? { |row| row["Email Address"].nil? }
  warn "  - warning: skipping orders without an email address:"
end
table.delete_if do |row|
  if row["Email Address"].nil?
    warn "             #{printable_order_summary(row)}"
    true
  end
end


# Finally, generate a new one that only includes the fields they want
table.by_col!
table.delete_if { |header, _data|
  !["First Name", "Last Name", "Email Address", "Phone", "Address", "Tags"].include?(header)
}


# Construct a new table where we only have one entry for each unique
# combination of name/email/phone/address, de-duping that person's tags as we go
personal_info_mapped_to_tags = Hash.new { |hash, key| hash[key] = [] }
table.by_row!
table.each do |row|
  key = [row["First Name"], row["Last Name"], row["Email Address"], row["Phone"], row["Address"]]
  personal_info_mapped_to_tags[key].concat(row["Tags"]).uniq!
end

output_string = CSV.generate do |csv|
  csv << ["First Name", "Last Name", "Email Address", "Phone", "Address", "Tags"]
  personal_info_mapped_to_tags.each_pair do |personal_info, tags|
    # Surround single tags in quotes only when they contain commas
    # https://mailchimp.com/help/format-guidelines-for-your-import-file/
    formatted_tags_field = tags.map { |t|
      if t.include?(",")
        "\"#{t}\""
      else
        t
      end
    }.join(",")
    csv << personal_info.push(formatted_tags_field)
  end
end

puts output_string

warn "Done.\n\n"
# TODO we can probably downcase everything when comparing for uniqueness (but
# careful, currently the keys ARE the data so we would need to separate that
# out)
# TODO the true unique value for MailChimp is the email address; this could
# resolve the collisions in the rest of the data.
